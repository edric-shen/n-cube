# Enterprise Rules Engine
The enterprise rules engine is a library for orchestrating, executing, and documenting business rules.
Start using the rules engine by following these simple steps:  
1. [Define rules](#define-rules)
2. [Define rule groups and categories](#define-rule-groups)  
3. [Define rule orchestration](#define-orchestration)  
4. [Execute the rules](#execute-rules)
5. [View rule documentation](#rule-documentation)  

Finally, review some [important concepts](#important-concepts) for writing rules.

##### Required Spring Properties (application.yml)
```yaml
ncube:
  target:
    host: ncube.gaig.com
    port: 443
    scheme: https
    username: <ncube_username>
    password: <ncube_password>
  rules:
    engines:
    -  
      name: <required> Unique name for the rules engine
      tenant: <optional> NCube ApplicationID tenant - defaults to NONE
      app: <required> NCube ApplicationID app
      version: <required> NCube ApplicationID version
      status: <optional> NCube ApplicationID status - defaults to RELEASE
      branch: <optional> NCube ApplicationID branch - defaults to HEAD
      rules: <required> NCube name where rules are defined
spring:
  profiles:
    active: ncube-client
```


## <a name="define-rules"></a> Define rules
Rules are defined as methods on a rule class.
- Create one or more rule classes that extend [BusinessRule](src/main/groovy/com/cedarsoftware/ncube/rules/BusinessRule.groovy)
- Document rules (methods and classes) using [@Documentation](src/main/groovy/com/cedarsoftware/ncube/rules/Documentation.groovy) 

##### BusinessRule Member Variables
- `List<RulesError> errors` - list for accumulating errors generated by rules
- `Object root` - primary root of a graph that rules operate on
- `Map input` - `NCube` input available to the rule class and NCubes
- `Map output` - `NCube` output available to the rule class and NCubes
- `ApplicationID appId` - `NCube ApplicationID` associated with the rules engine

##### Rule Class Examples 
- [Transformation Rules](src/test/groovy/com/cedarsoftware/ncube/rules/examples/Transform.java)  
- [Validation Rules](src/test/groovy/com/cedarsoftware/ncube/rules/examples/Validate.java)  

## <a name="define-rule-groups"></a> Define rule groups and categories
Rule groups and rule categories are defined in a [Decision Table](README-decision.md) `NCube`.
See the decision table documentation for requirements for setting up a decision table `NCube`.  

#### Rule Groups
A rule group is the unique combination of a rule class and a rule orchestration.
In addition to the decision table requirements, a rules engine `NCube` must have the following columns:

The `ruleGroup` cells should contain a `String` of the rule group name.  
The `className` cells should contain a `String` of the fully qualified class name.  
The `ncube` cells should contain a `String` of the name of the `NCube` where the rules are orchestrated.  
The `throwException` column is optional. Cells should be true if the rule group should throw a `RulesException` if any errors are recorded.  
No cells should be empty.  

#### Rule Categories (optional)
Rule categories are used to select rule groups based on metadata about the rule groups. For example, the category 
`phase` might used to categorize rule groups as either `pre-rating` or `post-rating`. Other example of ways to categorize
rules might be by product (workers compensation, commercial auto, etc.) or by mutability (mutable or immutable).

The cells should contain the value of the associated category, but it is permissible to leave cells empty.    

##### Example rule `NCube`
![](images/rule%20ncube.png)

## <a name="define-orchestration"></a> Define rule orchestration 
Rule orchestrations are defined in NCubes. 
A rule orchestration defines the order in which rules should be executed and the path of the graph being traversed.
An `NCube` used to define a rule orchestration must have the following:
- Axis `rules`, type `RULE`, data type `EXPRESSION`, check `Fire all matching`

Cells may contain simple references to rules.  
The rule class defined in the rule groups `NCube` gets put on `input.rule` so that rule methods can be called easily.  
Cells may reference other orchestration NCubes.  
Cells may contain code, including looping and referencing other NCubes.  

##### Example simple rule orchestration
- In this example, the first five cells show simple rule executions.  
- The last cell shows a reference to another orchestration `NCube` where the orchestration will continue traversing the graph.  

![](images/rule%20orchestration%20simple.png)

##### Rule orchestration with looping
- See the JavaDocs for [BusinessRule](src/main/groovy/com/cedarsoftware/ncube/rules/BusinessRule.groovy).runTargetRules().

## <a name="execute-rules"></a> Execute the rules
Rules are executed by specifying one of the following:
- A single rule group - `String` (does not use rule categories)
- A list of rule groups, in list order - `List<String>` (does not use rule categories)
- Selected categories - `Map<String, ?>` (see [Decision Table](README-decision.md))
- Selected categories - `Iterable<Map<String, ?>>` (see [Decision Table](README-decision.md))

```java 
rulesEngine.execute(<one of the above types>, root, input, ouput);
```

##### Example rule executions
[Demo](src/test/groovy/com/cedarsoftware/ncube/rules/examples/Demo.java)

If any errors are recorded while executing rules, a `RulesException` will be thrown after each rule group containing all the errors.

## <a name="rule-documentation"></a> View rule documentation  
Simply navigate to `/rules.html` from the base URL where the rules are running.

![](images/rules.png)

## <a name="important-concepts"></a> Important concepts
#### Mutable vs. immutable rules  
When defining rule types, it is best practice to not mix mutable rules with immutable rules. Define mutable rules and 
immutable rules in separate rule groups.

#### Stop between rule groups 
Currently, there is a hard stop between rule groups if any errors are recorded while executing rules within a rule group.
This can be useful to stop executing rules if rules in a second group rely on the successful completion of rules in the
first group.  

#### `NCube` input and output  
The `input` and `output` maps used by `NCube` are added as member variables of the base class `BusinessRule`.
Rating/pricing rules, for example, may have multiple outputs including prices, sub-totals, rates, etc. which can be stored on `output`. 


